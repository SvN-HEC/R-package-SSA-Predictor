{
lines(mplot[,i],col=colo[i])
mtext(colnames(mplot)[i],col=colo[i],line=-i)
}
}
axis(1,at=1+0:4*K/4,labels=expression(0, pi/4, 2*pi/4,3*pi/4,pi))
axis(2)
box()
}
lambda_HP<-lambda_HP
L<-L
HP_obj<-HP_target_mse_modified_gap(L,lambda_HP)
# Classic concurrent (one-sided) HP filter
hp_c<-HP_obj$hp_trend
ts.plot(hp_c,main=paste("One-sided (concurrent) HP(",lambda_HP,"): HP-C",sep=""),xlab="",ylab="")
# 4.1.2 Filter the indicators: apply HP-C
hp_c_mat<-NULL
for (i in 1:ncol(x_mat))
{
hp_c_mat<-cbind(hp_c_mat,filter(x_mat[,i],hp_c,side=1))
}
colnames(hp_c_mat)<-colnames(x_mat)
rownames(hp_c_mat)<-rownames(x_mat)
# Plot
mplot<-hp_c_mat
par(mfrow=c(1,1))
colo<-c(rainbow(ncol(mplot)))
main_title<-paste("Concurrent HP(",lambda_HP,") applied to indicators",sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (j in 1:ncol(mplot))
{
lines(mplot[,j],col=colo[j],lwd=1,lty=1)
mtext(colnames(mplot)[j],col=colo[j],line=-j)
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
# 4.1.3 Compute filter outputs for forecast horizons 0:6, assuming WN data
# Forecast horizons
h_vec<-0:6
hp_c_array<-array(dim=c(ncol(x_mat),nrow(x_mat),length(h_vec)))
for (j in 1:length(h_vec))
{
for (i in 1:ncol(x_mat))
{
# For forecast horizon h_vec[j], the first h_vec[j] filter coefficients are skipped (zeroes are appended at
#     the end).
#   -This simple rule is optimal if the data is (close to) WN (white noise).
#   -Log-returns of the indicators are fairly close to WN (one can inspect the ACFs)
hp_c_forecast<-c(hp_c[(h_vec[j]+1):L],rep(0,h_vec[j]))
hp_c_array[i,,j]<-filter(x_mat[,i],hp_c_forecast,side=1)
}
}
dimnames(hp_c_array)[[1]]<-colnames(x_mat)
dimnames(hp_c_array)[[2]]<-rownames(x_mat)
dimnames(hp_c_array)[[3]]<-paste("h=",h_vec,sep="")
i<-1
colnames(x_mat)[i]
# Plot HP nowcast and forecasts for that indicator: we scale the series for better visual inspection
mplot<-scale(hp_c_array[i,,])
colnames(mplot)<-paste(colnames(x_mat)[i],": h=",h_vec,sep="")
par(mfrow=c(1,1))
colo<-c(rainbow(ncol(mplot)))
main_title<-paste("HP(",lambda_HP,") now- and forecasts applied to ",colnames(x_mat)[i],sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (j in 1:ncol(mplot))
{
lines(mplot[,j],col=colo[j],lwd=1,lty=1)
mtext(colnames(mplot)[j],col=colo[j],line=-j)
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
recompute_results<-recompute_results
shift_vec<-shift_vec
if (recompute_results)
{
# Initialize performance matrices
ht_HP_c_mat<-p_mat_HP_c<-p_mat_HP_c_without_covid<-rRMSE_mSSA_comp_HP_c<-rRMSE_mSSA_comp_HP_c_without_covid<-MSE_oos_HP_c_without_covid_mat<-matrix(ncol=length(h_vec),nrow=length(h_vec)-1)
# Use WLS
use_garch<-F
# The following double loop computes all combinations of forward-shifts (of BIP) and forecast horizons
# -We compute HAC-adjusted p-values (significance of out-of-sample predictor) and
#  out-of-sample rRMSEs (relative root mean-square forecast errors) for the direct HP forecast
# Set-up progress bar: indicates progress in R-console
pb <- txtProgressBar(min=min(h_vec),max=max(h_vec)-1,style=3)
for (shift in shift_vec)#shift<-3
{
# Progress bar: see R-console
setTxtProgressBar(pb, shift)
for (j in h_vec)#j<-4
{
# Horizon j corresponds to k=j+1-th entry of array
k<-j+1
# Direct HP forecast:
#   -The explanatory variables are based on hp_c_array[,,k]
#   -We select all indicators (one could easily change this setting but results are only marginally effected as long as ifo and ESi are included)
if (length(sel_vec_pred)>1)
{
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),t(hp_c_array[sel_vec_pred,,k]))
} else
{
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),(hp_c_array[sel_vec_pred,,k]))
colnames(dat)[2]<-sel_vec_pred
}
rownames(dat)<-rownames(x_mat)
dat<-na.exclude(dat)
perf_obj<-optimal_weight_predictor_func(dat,in_out_separator,use_garch,shift,lag_vec)
# Retrieve out-of-sample performances: p-values and forecast MSE, with/without Pandemic
MSE_oos_HP_c<-perf_obj$MSE_oos
MSE_oos_HP_c_without_covid_mat[shift+1,k]<-MSE_oos_HP_c_without_covid<-perf_obj$MSE_oos_without_covid
p_mat_HP_c[shift+1,k]<-perf_obj$p_value
p_mat_HP_c_without_covid[shift+1,k]<-perf_obj$p_value_without_covid
perf_obj$track_weights
# Note that MSEs of M-SSA predictor were computed in exercise 1.3.5
rRMSE_mSSA_comp_HP_c[shift+1,k]<-sqrt(MSE_oos_mssa_comp_mat[shift+1,k]/MSE_oos_HP_c)
# Same but without Pandemic
rRMSE_mSSA_comp_HP_c_without_covid[shift+1,k]<-sqrt(MSE_oos_mssa_comp_without_covid_mat[shift+1,k]/MSE_oos_HP_c_without_covid)
ht_HP_c_mat[shift+1,k]<-compute_empirical_ht_func(perf_obj$cal_oos_pred)$empirical_ht
}
}
close(pb)
# Note: possible warnings issued by the GARCH estimation routine during computations can be ignored
# Assign column and rownames
colnames(p_mat_HP_c)<-colnames(p_mat_HP_c_without_covid)<-colnames(MSE_oos_HP_c_without_covid_mat)<-
colnames(rRMSE_mSSA_comp_HP_c)<-colnames(rRMSE_mSSA_comp_HP_c_without_covid)<-
colnames(ht_HP_c_mat)<-paste("h=",h_vec,sep="")
rownames(p_mat_HP_c)<-rownames(p_mat_HP_c_without_covid)<-rownames(rRMSE_mSSA_comp_HP_c)<-
rownames(MSE_oos_HP_c_without_covid_mat)<-rownames(rRMSE_mSSA_comp_HP_c_without_covid)<-
rownames(ht_HP_c_mat)<-paste("Shift=",shift_vec,sep="")
# Save results
list_2<-list(ht_HP_c_mat=ht_HP_c_mat,MSE_oos_HP_c_without_covid_mat=MSE_oos_HP_c_without_covid_mat,p_mat_HP_c=p_mat_HP_c,p_mat_HP_c_without_covid=p_mat_HP_c_without_covid,rRMSE_mSSA_comp_HP_c=rRMSE_mSSA_comp_HP_c,rRMSE_mSSA_comp_HP_c_without_covid=rRMSE_mSSA_comp_HP_c_without_covid)
if (T)
{
save(list_2,file=paste(getwd(),"/Results/list_2",sep=""))
}
} else
{
# Load results
load(file=paste(getwd(),"/Results/list_2",sep=""))
MSE_oos_HP_c_without_covid_mat=list_2$MSE_oos_HP_c_without_covid_mat
p_mat_HP_c=list_2$p_mat_HP_c
p_mat_HP_c_without_covid=list_2$p_mat_HP_c_without_covid
rRMSE_mSSA_comp_HP_c=list_2$rRMSE_mSSA_comp_HP_c
rRMSE_mSSA_comp_HP_c_without_covid=list_2$rRMSE_mSSA_comp_HP_c_without_covid
ht_HP_c_mat=list_2$ht_HP_c_mat
}
p_mat_mssa_components
p_mat_direct
p_mat_HP_c
p_mat_mssa_components_without_covid
p_mat_direct_without_covid
p_mat_HP_c_without_covid
# Findings:
# -Like the classic direct forecast, the new direct HP forecast is unable to forecast BIP at shifts larger
#     than one quarter (plus publication lag)
# -In contrast, the M-SSA components predictor remains significant for shifts up to four quarters (plus publication lag)
# We can compare the M-SSA components predictor to the direct forecast and the direct HP forecast in terms
#   of rRMSEs out-of-sample
rRMSE_mSSA_comp_direct_without_covid
rRMSE_mSSA_comp_HP_c_without_covid
# a. HP-C applied to BIP
i<-1
colnames(x_mat)[i]
# Plot HP-C for that indicator: we scale the series for better visual inspection
mplot<-scale(hp_c_array[i,,])
colnames(mplot)<-paste(colnames(x_mat)[i],": h=",h_vec,sep="")
par(mfrow=c(2,2))
colo<-c(rainbow(ncol(mplot)))
main_title<-paste("HP-C targeting HP-",colnames(x_mat)[i],sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (j in 1:ncol(mplot))
{
lines(mplot[,j],col=colo[j],lwd=1,lty=1)
mtext(colnames(mplot)[j],col=colo[j],line=-j)
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
# b. M-SSA applied to BIP
mplot<-scale(mssa_array[i,,])
colnames(mplot)<-paste(colnames(x_mat)[i],": h=",h_vec,sep="")
colo<-c(rainbow(ncol(mplot)))
main_title<-paste("M-SSA targeting HP-",colnames(x_mat)[i],sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (j in 1:ncol(mplot))
{
lines(mplot[,j],col=colo[j],lwd=1,lty=1)
mtext(colnames(mplot)[j],col=colo[j],line=-j)
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
# c. HP-C applied to spread
i<-5
colnames(x_mat)[i]
# Plot HP-C for that indicator: we scale the series for better visual inspection
mplot<-scale(hp_c_array[i,,])
colnames(mplot)<-paste(colnames(x_mat)[i],": h=",h_vec,sep="")
colo<-c(rainbow(ncol(mplot)))
main_title<-paste("HP-C targeting HP-",colnames(x_mat)[i],sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (j in 1:ncol(mplot))
{
lines(mplot[,j],col=colo[j],lwd=1,lty=1)
mtext(colnames(mplot)[j],col=colo[j],line=-j)
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
# d. M-SSA applied to spread
mplot<-scale(mssa_array[i,,])
colnames(mplot)<-paste(colnames(x_mat)[i],": h=",h_vec,sep="")
colo<-c(rainbow(ncol(mplot)))
main_title<-paste("M-SSA targeting HP-",colnames(x_mat)[i],sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (j in 1:ncol(mplot))
{
lines(mplot[,j],col=colo[j],lwd=1,lty=1)
mtext(colnames(mplot)[j],col=colo[j],line=-j)
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
recompute_results<-recompute_results
shift_vec<-shift_vec
if (recompute_results)
{
# Initialize performance matrices
rRMSE_mmse_comp_mean<-rRMSE_mmse_comp_mean_without_covid<-rRMSE_mmse_comp_mssa<-rRMSE_mmse_comp_mssa_without_covid<-matrix(ncol=length(h_vec),nrow=length(h_vec)-1)
# Use WLS
use_garch<-F
# The following double loop computes all combinations of forward-shifts (of BIP) and forecast horizons
# -We compute HAC-adjusted p-values (significance of out-of-sample predictor) and
#  out-of-sample rRMSEs (relative root mean-square forecast errors) for the direct HP forecast
# Set-up progress bar: indicates progress in R-console
pb <- txtProgressBar(min=min(h_vec),max=max(h_vec)-1,style=3)
for (shift in shift_vec)#shift<-2
{
# Progress bar: see R-console
setTxtProgressBar(pb, shift)
for (j in h_vec)#j<-5
{
# Horizon j corresponds to k=j+1-th entry of array
k<-j+1
# M-MSE component predictor
# Specify data matrix for WLS regression: we insert mmse_array instead of mssa_array for the explanatory variables
if (length(sel_vec_pred)>1)
{
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),t(mmse_array[sel_vec_pred,,k]))
} else
{
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),(mmse_array[sel_vec_pred,,k]))
}
rownames(dat)<-rownames(x_mat)
colnames(dat)<-c(colnames(x_mat)[1],sel_vec_pred)
dat<-na.exclude(dat)
perf_obj<-optimal_weight_predictor_func(dat,in_out_separator,use_garch,shift,lag_vec)
# Out-of-sample performances: p-values and forecast MSE, with/without Pandemic
MSE_oos_mmse<-perf_obj$MSE_oos
MSE_oos_mmse_without_covid<-perf_obj$MSE_oos_without_covid
MSE_oos_mean<-perf_obj$MSE_mean_oos
MSE_oos_mean_without_covid<-perf_obj$MSE_mean_oos_without_covid
# Compute rRMSEs
# a. M-MSE vs- M-SSA
#   Note that MSEs of M-SSA predictor were computed in exercise 1.3.5
rRMSE_mmse_comp_mssa[shift+1,k]<-sqrt(MSE_oos_mmse/MSE_oos_mssa_comp_mat[shift+1,k])
# Same but without Pandemic
rRMSE_mmse_comp_mssa_without_covid[shift+1,k]<-sqrt(MSE_oos_mmse_without_covid/MSE_oos_mssa_comp_without_covid_mat[shift+1,k])
# b. M-MSE vs. mean
rRMSE_mmse_comp_mean[shift+1,k]<-sqrt(MSE_oos_mmse/MSE_oos_mean)
# Same but without Pandemic
rRMSE_mmse_comp_mean_without_covid[shift+1,k]<-sqrt(MSE_oos_mmse_without_covid/MSE_oos_mean_without_covid)
}
}
close(pb)
# Note: possible warnings issued by the GARCH estimation routine during computations can be ignored
# Assign column and rownames
colnames(rRMSE_mmse_comp_mssa)<-colnames(rRMSE_mmse_comp_mssa_without_covid)<-
colnames(rRMSE_mmse_comp_mean)<-colnames(rRMSE_mmse_comp_mean_without_covid)<-paste("h=",h_vec,sep="")
rownames(rRMSE_mmse_comp_mssa)<-rownames(rRMSE_mmse_comp_mssa_without_covid)<-
rownames(rRMSE_mmse_comp_mean)<-rownames(rRMSE_mmse_comp_mean_without_covid)<-paste("Shift=",shift_vec,sep="")
# Save results
list_3<-list(rRMSE_mmse_comp_mssa=rRMSE_mmse_comp_mssa,rRMSE_mmse_comp_mssa_without_covid=rRMSE_mmse_comp_mssa_without_covid,
rRMSE_mmse_comp_mean=rRMSE_mmse_comp_mean,rRMSE_mmse_comp_mean_without_covid=rRMSE_mmse_comp_mean_without_covid)
if (T)
{
save(list_3,file=paste(getwd(),"/Results/list_3",sep=""))
}
} else
{
# Load results
load(file=paste(getwd(),"/Results/list_3",sep=""))
rRMSE_mmse_comp_mssa=list_3$rRMSE_mmse_comp_mssa
rRMSE_mmse_comp_mssa_without_covid=list_3$rRMSE_mmse_comp_mssa_without_covid
rRMSE_mmse_comp_mean=list_3$rRMSE_mmse_comp_mean
rRMSE_mmse_comp_mean_without_covid=list_3$rRMSE_mmse_comp_mean_without_covid
}
#-------------------
# Exercise 5.2: evaluate out-of-sample performances of M-MSE component predictor
#   -We here emphasize a four quarters ahead forecast (challenging forecast problem)
# 5.2.1 Compute Final M-MSE and M-SSA component predictors (whose regression relies on
#   the full data sample)
# Select h and shift (h should be be smaller than max(h_vec))
h<-6
if (h>max(h_vec))
h=max(h_vec)
# Select forward-shift
shift<-3
# Compute the final M-MSE component predictor optimized for forecast horizon h
# Note: for simplicity we here compute an OLS regression (WLS looks nearly the same)
if (length(sel_vec_pred)>1)
{
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),t(mmse_array[sel_vec_pred,,h+1]))
} else
{
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),(mmse_array[sel_vec_pred,,h+1]))
}
if (F)
{
# Weights for WLS regression: inverse prop. to GARCH-vola
#   Warnings are generated by garch-package and can be ignored
weight<-garch_vola_func(dat,shift,lag_vec)$weight
ts.plot(1/weight,main="GARCH(1,1) conditional variance")
# Regression
lm_obj<-lm(dat[,1]~dat[,2:ncol(dat)],weight=weight)
}
# Regression
lm_obj<-lm(dat[,1]~dat[,2:ncol(dat)])
summary(lm_obj)
optimal_weights<-lm_obj$coef
# Compute predictor for each forward-shift
if (length(sel_vec_pred)>1)
{
mmse_predictor<-optimal_weights[1]+dat[,2:ncol(dat)]%*%optimal_weights[2:length(optimal_weights)]
} else
{
mmse_predictor<-optimal_weights[1]+dat[,2:ncol(dat)]*optimal_weights[2:length(optimal_weights)]
}
# Compute the final M-SSA component predictor optimized for forecast horizon h
if (length(sel_vec_pred)>1)
{
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),t(mssa_array[sel_vec_pred,,h+1]))
} else
{
dat<-cbind(c(x_mat[(shift+lag_vec[1]+1):nrow(x_mat),1],rep(NA,shift+lag_vec[1])),(mssa_array[sel_vec_pred,,h+1]))
}
# Weights for WLS regression: inverse prop. to GARCH-vola
#   Warnings are generated by garch-package and can be ignored
if (F)
{
weight<-garch_vola_func(dat,shift,lag_vec)$weight
# Regression
lm_obj<-lm(dat[,1]~dat[,2:ncol(dat)],weight=weight)
}
lm_obj<-lm(dat[,1]~dat[,2:ncol(dat)])
summary(lm_obj)
optimal_weights<-lm_obj$coef
# Compute predictor for each forward-shift
if (length(sel_vec_pred)>1)
{
mssa_predictor<-optimal_weights[1]+dat[,2:ncol(dat)]%*%optimal_weights[2:length(optimal_weights)]
} else
{
mssa_predictor<-optimal_weights[1]+dat[,2:ncol(dat)]*optimal_weights[2:length(optimal_weights)]
}
# 5.2.2 Holding times
# Let's measure smoothness in terms of empirical holding-times
# -M-SSA imposes a larger HT (than the `natural' HT of M-MSE) and therefore it should be smoother
# -Notes:
#   1. We imposed a 50% larger expected (true) HT than M-MSE in the HT constraint of the optimization criterion
#     -Ideally, the empirical HT of M-SSA should be (roughly) 50% larger than M-MSE, too.
#   2. M-SSA controls crossings at the mean-level.
#     -Therefore we center the predictors when computing the empirical HT
compute_empirical_ht_func(scale(mssa_predictor))
compute_empirical_ht_func(scale(mmse_predictor))
par(mfrow=c(1,1))
ts.plot(scale(cbind(mssa_predictor,mmse_predictor)),col=c("blue","green"))
abline(h=0)
# M-SSA has approximately 33% less crossings (roughly 50% larger empirical HT)
# 6.1 Up-date M-SSA and M-MSE
# In-sample span for VAR, use all data for VAR
date_to_fit<-"3000"
# Remove Pandemic
x_mat_wc<-x_mat[c(which(rownames(x_mat)<2020),which(rownames(x_mat)>2021)),]
par(mfrow=c(1,1))
ts.plot(x_mat_wc)
# Run the M-SSA wrapper, see tutorial 7.2
#   -The function computes M-SSA and M-MSE for each forecast horizon h in h_vec
final_mssa_indicator_obj<-compute_mssa_BIP_predictors_func(x_mat_wc,lambda_HP,L,date_to_fit,p,q,ht_mssa_vec,h_vec,f_excess,lag_vec,select_vec_multi)
# Final M-SSA components
final_mssa_array<-final_mssa_indicator_obj$mssa_array
# Final M-MSE components
final_mmse_array<-final_mssa_indicator_obj$mmse_array
#----------------------
# 6.2 Compute up-dated M-SSA and M-MSE component predictors based on WLS regression
# Select h and shift (should be smaller or equal 5 or 6)
# We select a one-year ahead forecast h=4, for its potential importance in applications
# Background (short resume):
# -The forecast horizon h conditions M-SSA to track HP-filtered targets h-steps ahead
# -The corresponding M-SSA or M-MSE components are then used as regressors in the subsequent WLS regressions
#   on forward-shifted BIP
# -The output of the WLS regressions are the M-SSA and M-MSE component predictors
#   -Two-stage (stacked) predictor design
# One can `play' with the settings
# Select M-SSA components
sel_vec_pred<-sel_vec_pred
# Select Forecast horizon (determines M-SSA optimization)
h<-4
if (h>6)
h=6
# Select forward-shift:
#   -WLS regression targets BIP shifted forward by shift (+publication lag)
shift<-3
# 6.2.1 M-MSE component predictor optimized for forecast horizon h
# We here rely on GARCH(1,1) and WLS regression
if (length(sel_vec_pred)>1)
{
dat<-cbind(c(x_mat_wc[(shift+lag_vec[1]+1):nrow(x_mat_wc),1],rep(NA,shift+lag_vec[1])),t(final_mmse_array[sel_vec_pred,,h+1]))
} else
{
dat<-cbind(c(x_mat_wc[(shift+lag_vec[1]+1):nrow(x_mat_wc),1],rep(NA,shift+lag_vec[1])),(final_mmse_array[sel_vec_pred,,h+1]))
}
if (F)
{
# Compute WLS weight: inverse proprtional to GARCH-vola
#   Warnings are generated by garch-package and can be ignored
weight<-garch_vola_func(dat,shift,lag_vec)$weight
# Regression
lm_obj<-lm(dat[,1]~dat[,2:ncol(dat)],weight=weight)
}
lm_obj<-lm(dat[,1]~dat[,2:ncol(dat)])
summary(lm_obj)
optimal_weights<-lm_obj$coef
# Compute predictor for each forward-shift
if (length(sel_vec_pred)>1)
{
final_mmse_predictor<-optimal_weights[1]+dat[,2:ncol(dat)]%*%optimal_weights[2:length(optimal_weights)]
} else
{
final_mmse_predictor<-optimal_weights[1]+dat[,2:ncol(dat)]*optimal_weights[2:length(optimal_weights)]
}
# 6.2.2 M-SSA component predictor optimized for forecast horizon h
# We here rely on GARCH(1,1) and WLS regression
if (length(sel_vec_pred)>1)
{
dat<-cbind(c(x_mat_wc[(shift+lag_vec[1]+1):nrow(x_mat_wc),1],rep(NA,shift+lag_vec[1])),t(final_mssa_array[sel_vec_pred,,h+1]))
} else
{
dat<-cbind(c(x_mat_wc[(shift+lag_vec[1]+1):nrow(x_mat_wc),1],rep(NA,shift+lag_vec[1])),(final_mssa_array[sel_vec_pred,,h+1]))
}
# Regression
if (F)
{
lm_obj<-lm(dat[,1]~dat[,2:ncol(dat)],weight=weight)
}
lm_obj<-lm(dat[,1]~dat[,2:ncol(dat)])
summary(lm_obj)
optimal_weights<-lm_obj$coef
# Compute predictor for each forward-shift
if (length(sel_vec_pred)>1)
{
final_mssa_predictor<-optimal_weights[1]+dat[,2:ncol(dat)]%*%optimal_weights[2:length(optimal_weights)]
} else
{
final_mssa_predictor<-optimal_weights[1]+dat[,2:ncol(dat)]*optimal_weights[2:length(optimal_weights)]
}
# 6.2.3 Plot final M-MSE and M-SSA predictors
par(mfrow=c(2,1))
mplot<-scale(cbind(c(x_mat_wc[(shift+lag_vec[1]+1):nrow(x_mat_wc),1],rep(NA,shift+lag_vec[1])),final_mssa_predictor,final_mmse_predictor))
colnames(mplot)<-c(paste("BIP shifted forward by ",shift," (plus publication lag)",sep=""),"M-SSA component predictor","M-MSE component predictor")
colo<-c("black","blue","green")
main_title<-paste("Forward-shifted BIP and Predictors: Pandemic episode removed",sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (jj in 1:ncol(mplot))#jj<-2
{
lines(mplot[,jj],col=colo[jj],lwd=1,lty=1)
mtext(colnames(mplot)[jj],col=colo[jj],line=-jj)
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
mplot<-cbind(rep(0,nrow(as.matrix(final_mssa_predictor))),final_mssa_predictor,final_mmse_predictor)
colnames(mplot)<-c("","M-SSA component predictor","M-MSE component predictor")
main_title<-paste("Predictors: M-SSA component vs. M-MSE component, h=",h,", shift=",shift,sep="")
plot(mplot[,1],main=main_title,axes=F,type="l",xlab="",ylab="",col=colo[1],ylim=c(min(na.exclude(mplot)),max(na.exclude(mplot))))
mtext(colnames(mplot)[1],col=colo[1],line=-1)
for (jj in 1:ncol(mplot))
{
lines(mplot[,jj],col=colo[jj],lwd=1,lty=1)
mtext(colnames(mplot)[jj],col=colo[jj],line=-jj)
}
abline(h=0)
axis(1,at=c(1,12*1:(nrow(mplot)/12)),labels=rownames(mplot)[c(1,12*1:(nrow(mplot)/12))])
axis(2)
box()
compute_empirical_ht_func(final_mssa_predictor)
compute_empirical_ht_func(final_mmse_predictor)
